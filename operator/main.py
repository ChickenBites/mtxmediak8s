import kopf
import yaml
import os
import time
from kubernetes import client
from kubernetes.client import V1ObjectMeta

NS = os.getenv("OPERATOR_NAMESPACE", "mediamtx")

# ---------- helpers ----------

# Splits a list of URLs into chunks of size n.
# This is how we decide which streams go into each MediaMTX instance.

def chunk(lst, n):
    return [lst[i:i+n] for i in range(0, len(lst), n)]

# Generates a consistent name for each MediaMTX instance.
# Example: "bunny-aggregator-mtx-0", "bunny-aggregator-mtx-1".

def name_for_instance(streamset_name, idx):
    return f"{streamset_name}-mtx-{idx}"

# Builds the MediaMTX configuration file.
# Defines HLS/RTMP/RTSP enabled, and creates empty paths for ffmpeg to publish into.

def mtx_config(urls, hls_enabled=True):
    cfg = {
        "hls": hls_enabled,
        "rtmp": True,
        "rtsp": True,
        "paths": {},
    }
    # define empty paths for ffmpeg to publish into
    for i, _ in enumerate(urls):
        cfg["paths"][f"live/stream-{i:04d}"] = {}
    return "# Generated by operator\n" + yaml.safe_dump(cfg)

# Generates a shell script that runs ffmpeg for each URL.
# Each ffmpeg process ingests a remote HLS stream and pushes it into RTMP at a unique path.

def loader_script(urls, instance_host):
    lines = ["#!/bin/sh", "set -eu", "echo \"Starting stream loader...\""]
    for i, u in enumerate(urls):
        path = f"stream-{i:04d}"
        out = f"rtmp://{instance_host}:1935/live/{path}"
        cmd = (
            f"ffmpeg -re -i '{u}' "
            f"-c:v copy -c:a aac -f flv '{out}' "
            f">/tmp/ffmpeg-{path}.log 2>&1 &"
        )
        lines.append(f"echo \"Ingest {u} -> {out}\"")
        lines.append(cmd)
    lines.append("wait || true")
    return "\n".join(lines)

# Ensures a ConfigMap exists with the given data.
# Creates it if missing, replaces it if already present.

def ensure_configmap(api: client.CoreV1Api, name: str, data: dict):
    cm = client.V1ConfigMap(metadata=V1ObjectMeta(name=name, namespace=NS), data=data)
    try:
        api.replace_namespaced_config_map(name=name, namespace=NS, body=cm)
    except client.exceptions.ApiException as e:
        if e.status == 404:
            api.create_namespaced_config_map(namespace=NS, body=cm)
        else:
            raise

# Ensures a Service exists for each MediaMTX instance.
# Exposes HLS, RTMP, and RTSP ports so clients can connect.

def ensure_service(api: client.CoreV1Api, name: str):
    svc = client.V1Service(
        metadata=V1ObjectMeta(name=name, namespace=NS, labels={"app": name}),
        spec=client.V1ServiceSpec(
            selector={"app": name},
            ports=[
                client.V1ServicePort(name="hls", port=8888, target_port=8888),
                client.V1ServicePort(name="rtmp", port=1935, target_port=1935),
                client.V1ServicePort(name="rtsp", port=8554, target_port=8554),
            ],
            type="ClusterIP",
        ),
    )
    try:
        api.replace_namespaced_service(name=name, namespace=NS, body=svc)
    except client.exceptions.ApiException as e:
        if e.status == 404:
            api.create_namespaced_service(namespace=NS, body=svc)
        else:
            raise

# Ensures a Deployment exists for each MediaMTX instance.
# Each Deployment runs two containers: MediaMTX and the ffmpeg loader sidecar.

def ensure_deployment(apps_api: client.AppsV1Api, name: str, mtx_image: str, loader_image: str):
    dep = client.V1Deployment(
        metadata=V1ObjectMeta(name=name, namespace=NS),
        spec=client.V1DeploymentSpec(
            replicas=1,
            selector=client.V1LabelSelector(match_labels={"app": name}),
            template=client.V1PodTemplateSpec(
                metadata=V1ObjectMeta(labels={"app": name}),
                spec=client.V1PodSpec(
                    containers=[
                        client.V1Container(
                            name="mediamtx",
                            image=mtx_image,
                            args=["/config/mediamtx.yml"],
                            ports=[
                                client.V1ContainerPort(container_port=8888, name="hls"),
                                client.V1ContainerPort(container_port=1935, name="rtmp"),
                                client.V1ContainerPort(container_port=8554, name="rtsp"),
                            ],
                            volume_mounts=[client.V1VolumeMount(name="mtx-config", mount_path="/config")],
                        ),
                        client.V1Container(
                            name="stream-loader",
                            image=loader_image,
                            command=["/bin/sh", "/loader/loader.sh"],
                            volume_mounts=[client.V1VolumeMount(name="loader-scripts", mount_path="/loader")],
                        ),
                    ],
                    restart_policy="Always",
                    volumes=[
                        client.V1Volume(
                            name="mtx-config",
                            config_map=client.V1ConfigMapVolumeSource(name=f"{name}-mtx-config"),
                        ),
                        client.V1Volume(
                            name="loader-scripts",
                            config_map=client.V1ConfigMapVolumeSource(name=f"{name}-loader"),
                        ),
                    ],
                ),
            ),
        ),
    )
    try:
        apps_api.replace_namespaced_deployment(name=name, namespace=NS, body=dep)
    except client.exceptions.ApiException as e:
        if e.status == 404:
            apps_api.create_namespaced_deployment(namespace=NS, body=dep)
        else:
            raise

# ---------- kopf handlers ----------
# Logs the operator namespace on startup.

@kopf.on.startup()
def startup(logger, **kwargs):
    logger.info(f"Operator namespace: {NS}")

# Timer to keep operator alive and log activity every 60s.

@kopf.timer('media.example.com', 'v1alpha1', 'streamsets', interval=60.0)
def keepalive(name, namespace, logger, **kwargs):
    logger.info(f"Keepalive tick for StreamSet {name} in {namespace}")

# Background daemon that logs a heartbeat every 30s.

@kopf.daemon('media.example.com', 'v1alpha1', 'streamsets')
def heartbeat_daemon(stopped, name, namespace, logger, **kwargs):
    logger.info(f"Heartbeat daemon started for StreamSet {name} in {namespace}")
    while not stopped.is_set():
        time.sleep(30)
    logger.info(f"Heartbeat daemon stopping for StreamSet {name}")

# Main reconcile handler: creates/updates instances and cleans up extras.

@kopf.on.create("media.example.com", "v1alpha1", "streamsets")
@kopf.on.update("media.example.com", "v1alpha1", "streamsets")
def reconcile(spec, name, namespace, status, logger, **kwargs):
    logger.info(f"Reconciling StreamSet {name} in {namespace} with spec={spec}")
    if namespace != NS:
        return {"message": f"ignored namespace {namespace}"}

    urls = spec.get("urls", [])
    hls_enabled = bool(spec.get("hlsEnabled", True))
    per = int(spec.get("instanceSize", 10))
    mtx_image = spec.get("mediamtxImage", "bluenviron/mediamtx:latest")
    loader_image = spec.get("loaderImage", "jrottenberg/ffmpeg:5.1-alpine")

    assignments = chunk(urls, per)
    required = len(assignments)

    core = client.CoreV1Api()
    apps = client.AppsV1Api()

    # create/update required instances
    for idx, lst in enumerate(assignments):
        inst_name = name_for_instance(name, idx)
        ensure_configmap(core, f"{inst_name}-mtx-config", {"mediamtx.yml": mtx_config(lst, hls_enabled)})
        script = loader_script(lst, inst_name)
        ensure_configmap(core, f"{inst_name}-loader", {"loader.sh": script})
        ensure_service(core, inst_name)
        ensure_deployment(apps, inst_name, mtx_image, loader_image)
        logger.info(f"Reconciled instance {inst_name} with {len(lst)} streams")

    # cleanup extra instances if stream count shrinks
    existing = apps.list_namespaced_deployment(namespace=NS).items
    for dep in existing:
        if dep.metadata.name.startswith(name + "-mtx-"):
            idx = int(dep.metadata.name.split("-mtx-")[1])
            if idx >= required:
                logger.info(f"Deleting extra instance {dep.metadata.name}")
                apps.delete_namespaced_deployment(name=dep.metadata.name, namespace=NS)
                try:
                    core.delete_namespaced_service(name=dep.metadata.name, namespace=NS)
                except client.exceptions.ApiException:
                    pass
                try:
                    core.delete_namespaced_config_map(name=f"{dep.metadata.name}-mtx-config", namespace=NS)
                except client.exceptions.ApiException:
                    pass
                try:
                    core.delete_namespaced_config_map(name=f"{dep.metadata.name}-loader", namespace=NS)
                except client.exceptions.ApiException:
                    pass
    # Update CR status with current assignments
    status = {
        "instances": required,
        "assignments": [
            {"instanceName": name_for_instance(name, i), "urls": lst}
            for i, lst in enumerate(assignments)
        ],
    }
    return status
